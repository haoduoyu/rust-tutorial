第四章

复习**控制流**

包含条件语句、循环语句两种，条件语句有`if`、`if-else`、`if-else if-else`等几种，循环语句包含loop（无其他操作则进行无限重复的行为，简称死循环）、while、for等，以上三种循环基本可以互相转换，至于哪种更容易、更简便需要根据实际的情况判断。

以下是控制流的格式

```rust
// 1
if condition {
  // do something
}

// 2
if condition1 {
  // do something
} else if condition2 {
  // do something
} else {
  // do something
}

// 3
if condition {
  // do something
} else {
  // do something
}

// 4
loop {
  // do something
}

// 5
while condition {
  // do something
}

// 6
for item in iterator {
  // do something
}

```

----

这一部分内容比较简单，但是是rust的一个非常重要的概念，也是当前推崇这个语言的比较重要的原因之一。

### **所有权**

所有权具体含义可以从名字上推断出来，所有权主要用在变量上，或者说某一块内存空间的拥有者是谁，谁是这块内存的主人。

其实Rust中的所有权和C中的指针一样，被很多人赋予了很强大的能力（确实是），但是也同时让很多人在接触到这个语言时候、去学习这部分内容的时候就被灌输了“它很难”的观念。可以通过它的定义，以及相关的示例去观察、理解。

在详细说明所有权前，需要简单说明一下内存相关的内容。

（不重要，可略过）我们在通过编程语言去使用内存的时候，一般会区分出堆和栈。我们可以这样理解，每一台电脑都会有内存，内存就是那么一个条形的物体，将它插在电脑上，在电脑有操作系统并且可以正常使用的情况下，内存就提供了数据交换，以及其他临时存储的作用（不准确的说法，这里不对正确的定义过于深究）。当我们用程序语言（后面用‘代码’代替这种说法）去创建、使用变量的时候，实际上是将变量存到了内存里面，这里指的内存是实际的硬件，在操作系统中的一个映射，如果直接说内存的话，就代表是在操作系统中的形态。

（不重要，可略过）我们创建的变量，以及创建函数、调用函数时候都会用到内存。当我们写好一段代码，点击运行（cargo run）的时候，我们代码会请求操作系统给个地方去运行代码，请求的这个地方就是内存，需要请求多大，这个根据实际的情况（参考操作系统知识），申请到内存后，就需要一行行的去运行代码，当运行到创建变量时候，就需要给这个变量创建一块区域，去存储他的值，因为我们创建的变量有很多类型，例如数值型（u32,i16等），有布尔类型（bool），有字符类型（char），这些类型在创建的时候就可以推算出来他们的大小，例如正常的一个整数是4个字节，一个布尔、一个字符类型是一个字节等，这时候我们就在内存中，一块叫做栈的地方，划分出来指定大小的区域给这个变量去使用，像字符串（String）、结构体（struct）等类型，没有办法在编译时期确认他的大小，所以就需要在创建的时候放到一个叫做堆的地方，这里指的没有办法确定大小并不是绝对的，只需要记住这个话就好，又不需要做题，实际用到了可以自己去判断。

（不重要，可略过）前面指的堆、栈，其实是我们将内存人为的、在概念上划分的两块区域，堆里面存的都是开始不能确定大小的，在运行期，到了那一点才知道大小的值，或者是动态变化的（如列表vec类型）的一些变量；而栈，在编译期就可以知道大小的变量就存在这里，当然了在运行过程中，一个函数被调用了，也会被放到栈里面，当函数调用结束，就从栈里面去移除，有兴趣的话可以单独查阅一下相关的知识点，或者探讨一下，如果不做题，不做优化相关的事情，只是先简单的学习的话，可以先不用完全搞清楚堆栈的深层次的区别。

总结一下，堆就是存一些不定大小的变量，栈存一些可以在编译期确定大小的变量，或者在函数调用的时候存一下。

内存相关的点说完了，下面说一下和所有权相关的东西了。

Rust在创建变量的时候也会使用到堆、栈相关的内存，如果变量存在了栈这边，基本可以忽略所有权的问题（只是写代码的时候不用考虑，不代表这里和所有权没关系），如果存在了堆那边，需要掌握所有权的基本规则。

下面先列出来所有权的规则内容

```
1、Rust中的每一个值都有一个对应的变量作为它的所有者。
2、在同一时间内，值有且仅有一个所有者。
3、当所有者离开自己的作用域时，它持有的值就会被释放掉。
```

对上面的几条内容展开说明一下

1、当我们使用`let`创建一个变量，并且同时给他赋予了一个值，例如`let num = 1`，这时候，num就是1这个值的所有者；有些地方会看到num或者说是变明名是资源的所有者，这里的资源可以是电脑上的文件，也可以是一些硬件设备的句柄（可以理解为注册到操作系统里的唯一标识，通过这个标识可以找到对应的设备），这样就不难理解资源的意思了。

2、在某一时刻，某个值只能有一个所有者，例如`let s = String::from("hello"); let s2 = s;`当我们执行第一句`let s = String::from("hello")`的时候，这和第一条是一致的，s成为了hello的所有者（拥有者或者说是主人），当执行到第二条代码`let s2 = s;`的时候，hello的所有者变成了s2，这个时候s就没有用了，可以认为刚开始有一个人买了一个东西，然后将这个东西送给了另外一个人，东西还是同一个，但是主人已经变了，只有第二个人才具有支配的权利。

3、这里需要说明一下“作用域”，我们在正常写代码的时候会用到这个符号`{}`，即一对花括号，他们一定是成对出现的，在每一对`{}`中间的部分都成为一个作用域，作用域可以嵌套，例如`{{}}`，最内层的一对是一个作用域，同时它也存在于外层的一对`{}`作用域内，一旦到达`{`就代表进入了一个新的作用域，一旦到达`}`就代表即将离开作用域。所以第三条意思是，只要一个变量到达了他所在作用域的`}`位置，代表了他即将失效，出了`}`他就没有用了。

下面用代码解释一下前面三条内容

```rust
// 1、Rust中的每一个值都有一个对应的变量作为它的所有者。
let num = 1; // 这里num就是1这个值的所有者
let s1 = String::from("hello"); // 这里s是String::from("hello")字符串的所有者
let b = true; // 这里b是true这个值的所有者

// 2、在同一时间内，值有且仅有一个所有者。
let s1 = String::from("hello");
let s2 = s1; // 这里通过赋值语句，s1将自己的拥有的hello给了s2，这时候s1就失效了
let s3 = s1; // 前面提到了同一时刻只能有一个所有者，同时s1赋值给了s2，s1就失效了，所以这里会报错
let s3 = s2; // 这句不会报错，因为s2此时是拥有hello的，所以可以赋值给s3，同时s2失效

// 3、当所有者离开自己的作用域时，它持有的值就会被释放掉。
fn main() { // 这是一个新的作用域，这里认为他是作用域1
    let num1 = 1;

    { // 这里是新的作用域，命名为作用域2
        let num2 = 2;
        println!("{}", num1); // 因为num1在更大的作用域定义的，所以这里可以访问
        println!("{}", num2); // num2 也可以正常访问
    } // 作用域2结束

    println!("{}", num1); // 因为这里还在作用域1范围内，所以这里征程
    println!("{}", num2); // 因为num2是在作用域2内定义的，所以到这里的时候作用域2已经结束了，所以这里会报错，访问不到
}// 这是作用域1的结束


```

上面是所有权基本规则的介绍，以及详细的一个说明，后面提到的借用啦，引用啦等等概念都是在前面三条原则基础上进行推导（实际上没有推导，都是直接应用）。

不过有些人应该会注意到下面代码提到的问题

```rust
// demo1
let num1 = 1;
let num2 = num1;

println!("{}", num1); // 正常
println!("{}", num2); // 正常

// demo2
let str1 = String::from("hello");
let str2 = str1;

println!("{}", str1); // 报错
println!("{}", str2); // 正常
```

上面两个demo，可以看到，第一个demo的两个输出都是对的，但是第二个就会有错误；第一个demo看起来和第二原则似乎有点出入，num1那里明明已经赋值给num2了为什么后面还可以使用，这里就是我们即将要提到的Copy和Clone两个概念。

Copy和Clone从名字上其实都有赋值，搞出来一个副本的意思，但是他们有点小区别。

1、copy的定义是这样的`pub trait Copy: Clone`，这里trait可以认为是java里面的interface，Copy：Clone的意思是copy是clone的子类（在Rust里这么说不贴切），所以有了copy特征，一定就有clone的特征；

2、copy通常用于可以在栈上表示的类型，也就是说它们自身没有任何部分位于堆上；Clone有一个名为clone的方法，用于获取接受者的不可变引用，并返回相同类型的新值。

3、Copy是自动化特征，大多数栈上的数据类型都自动实现了它，而Clone需要显式调用clone去操作。

从上面的说明，以及前面的介绍不难看出，默认拥有并且使用Copy的一些类型都在栈上，例如整数(u32,u64,i64等)，布尔值(bool)等；而String这种就不行，它因为不定长，所以实现了Clone的方式，如果想复制一份给别人，同时自己的所有权不变，那就应该调用clone方法，例如`str1.clone()`，这时候是得到了str1的一个引用（副本）。

Copy和Clone比较简单的记法就是除了简单变量使用copy，自动（隐式）复制外，其他的都是需要手动调用clone方法。

**借用、引用**

借用和引用通常一起出现去说明，从名字上看，借用就是把东西借过来，用完要还回去，如果不还就属于借用人的了，这样一旦借用人瞎搞这个东西就坏了、完了；前面和字符串相关的demo，在str1赋值给str2的时候，就是相当于str2借用了str1的值，如果str2不还回去，str1就不能用了，因为不在str1手里了。

引用可以理解为给起了一个别名，例如张三，可以有一个小名叫二狗子，这样你看到张三你知道是他，你看到二狗子也知道是他；所以引用类似创建了一个别名指向了同一个人或物。

涉及到所有权问题的时候，基本都可以认为是某个值被借用走了，如果想让事情处理起来简单一点，就不要直接借出去，而使用引用的方式。可以阅读下面的例子进行理解。

```rust
fn test_func(s: String) {
    // do somethine
}

fn main() {
    let str1 = String::from("hello"); // 1、定义了一个字符串str1
  	// 2、调用了这个函数，并且将str1传递给了test_func函数，
    //根据前面讲的，这里str1的值相当于借给了test_func函数中的参数s，
    //这样，hello这个值在str1这里就不能用了，hello的所有者变成了s
  	// 这个过程我们可以说，str1的值移动到了s上面，也可以说，str1的值借给了s，
  	// 所以在调用了这个函数后，str1就失效了，所以下面3那里会报错
    test_func(str1); 
    println!("{}", str1); // 3
}
```

如果想改正上面的代码使其能够正常运行，我们提供两种方式，这两种方式虽然都可以解决问题，但是在实际应用中需要根据当时的情况决定。

方案1

```rust
fn test_func(s: String) {
    // do somethine
}

fn main() {
    let str1 = String::from("hello");
    // 相较于前面的代码，只改动了下面这一行，增加了clone，
    // clone操作可以复制一份str1的内容，然后传递到函数的s参数中
  	// 这样就可以保留了str1对原有hello的所有权，同时复制了一个新的给了s
    test_func(str1.clone());
    println!("{}", str1);
}
```

方案2

```rust
// 参数的类型前面添加了 & 符号
fn test_func(s: &String) {
    // do somethine
}

fn main() {
    let str1 = String::from("hello");
  	// 调用的时候也添加了 & 符号
  	// 这里使用&代表了给str1创建了一个别名，这个别名叫做s，
  	// 这样s和str1指向了同一个值hello。
  	// 更准确的说，这里创建了一个str1的引用，然后给了s，
  	// 这里是不可变引用，如果是可变的需要添加mut，即&mut str1
  	// 这需要函数定义那里改成s: &mut String，同时str1定义的时候也需要
  	// 是mut去修饰，即let mut str1 = xxxxf
    test_func(&str1);
    println!("{}", str1);
}
```

前面提到了函数的调用过程中涉及到的引用、借用的操作，下面再说一下在普通作用域时候的例子以及原则。

```rust
fn main() {
    let str1 = String::from("hello");
    let str2 = &str1;
    let str3 = &str1;
}
```

上面这段代码没有任何问题，给str1创建了两个引用，一个是str2，一个是str3，因为他们都是不可变的引用，所以也不用担心会有问题，上面这种样子，rust不会有什么特别的操作。

```rust
fn main() {
    let mut str1 = String::from("hello");
    let str2 = &str1;
    let str3 = &mut str1;
    let str4 = &str1;
	  // let str5 = &mut str1; // 如果这行注释放开就错了，如果这行移到str3和str4中间放开就没问题，其实这里我也没有想明白，还需要查阅官方的升级日志说明
}
```

上面这种写法，在我开始学习rust的时候是不允许的，上面那种写法会有错误，因为rust规定，只读（不可变）引用可以创建无数多个，但是一旦创建了可变引用就不允许创建引用了，无论可变不可变，但是好像rust编译器更新了，对上面的这段代码做了更好的改动，它不会认为上面有问题，不过也符合正常逻辑，因为我那么几行代码我虽然创建了可变、不可变引用，但是我没有进行其他操作，所以也没必要进行报错。

```rust
// demo 1
fn main() {
    let mut str1 = String::from("hello");
    let str2 = &str1;
    let str3 = &mut str1;
    let str4 = &str1; // 这里会报错，可以这样理解，前面定义了一个可变引用，如果后面没有使用可变引用的情况下就不会有任何的问题，但是如果使用了可变引用，就会引起str1的变动，但是这里str4是在一个可变引用后进行的不可变引用，str4就存在str3变动而因为原值的变动，因为str2没有使用到，所以不会引起其他的错误

    println!("{}", str3);
}

// demo 2
// 这段不会有问题，因为大家都是不可变引用
fn main() {
    let mut str1 = String::from("hello");
    let str2 = &str1;
    // let str3 = &mut str1;
    let str4 = &str1;

    println!("{}", str2);
    println!("{}", str4);
    // println!("{}", str3);
}

// demo 3
// 下面会有两处错误，其实解释和前面demo1差不多
fn main() {
    let mut str1 = String::from("hello");
    let str2 = &str1;
    let str3 = &mut str1;
    let str4 = &str1;

    println!("{}", str2); // 导致 let str3 = &mut str1; 错误
    println!("{}", str3); // 导致 let str4 = &str1;，
    println!("{}", str4);
}
```

注：前面几个demo提到的错误问题，我还需要查阅官方的资料确认细节问题，不过这里提出来是为了做记录，也是我这几天为了记录内容发现的细节，不过正常开发情况下，牢记几个所有权的规则，以及后面提到的引用的规则就足够了。

引用的规则

```
1、在任何一段给定的时间里，要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
2、引用总是有效的。
```

解释：第一条其实从前面demo可以看出来并不是完全正确的，但是可以按照这条规则去写代码，可以保证不会有问题，实际编译器很宽松，但是上面规则更加严格一些；另外，参照另外资料：可变借用是一种独占性借用（我觉得用引用更合适）；第二条需要补充一点，引用的变量，只有在原变量有效的情况下，引用总是有效的，当原变量超出作用域而失效了，引用也会失效。

所有权的内容差不多就是这些了，后面会通过切片去说明引用、借用的使用。同时还会有生命周期（这个会比较后面的位置，有些书会和所有权放到一起）的使用等。

这篇就先记录到这里。