第四章

**所有权复习**

所有权规则

```
1、Rust中的每一个值都有一个对应的变量作为它的所有者。
2、在同一时间内，值有且仅有一个所有者。
3、当所有者离开自己的作用域时，它持有的值就会被释放掉。
```

引用规则

```
1、在任何一段给定的时间里，要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
2、引用总是有效的。
```

----

**切片（Slice）**

切片是接着引用部分继续讲解的。切片是另外一种不持有所有权的数据类型，切片允许我们引用集合中某一段连续的元素序列，而不是整个集合。

考虑一下这个问题：编写一个函数，函数接受一个字符串参数，并将字符串的首个单词作为函数的返回值。这时候如果字符串那种不包含空格，那么就需要返回整个字符串。

对于上面的问题，我们可以假设函数有下面这样的签名（很多地方使用签名这个说法，其实可以认为是函数的定义形式、“样貌”）

```rust
fn first_word(s: &String) -> ? // 这里暂时用 '?' 占位
```

因为我们只需要获取字符串的部分（全部）内容并返回，并没有对变量进行写入操作，所以这里可以使用不可变引用作为参数（这里提示一下，如果是可变引用的话应该这样写 s: &mut String）。因为还没有提到过怎么获取部分字符串的方法，所以这里可以可以先采用这种方式：查询字符串的每一个位置，当遇到空格符的时候就将索引值（下标，即空格的位置）返回，这时候我们可以完善一下代码，代码如下。

```rust
// 之所以返回usize是因为字符串中下标位置是大于等于零的，这里暂时不考虑传递空字符串的情况
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes(); // 为了遍历需要转成字节类型

  	// bytes.iter().enumerate() 是为了获取字节的可遍历对象并封装成元组
    for (i, &item) in bytes.iter().enumerate() {
      	// if 判断字符串某个位置是否为空格
        if item == b' ' {
            return i;
        }
    }
		// 如果前面没有找到空格，就返回整个长度
    s.len()
}

fn main() {
    let s = String::from("hello world");

    let word = first_word(&s);

    println!("{}", word); // 这里会输出5
}
```

可以看到，上面函数会返回一个下标值，假设在输出前添加 `s.clear()`，同时定义的地方改为`let mut s = String::from("hello world")`，这时候虽然运行结果没有变化，但是因为s调用了清空方法，成了空字符串，这时候word=5就失去了意义，也就是说，这种方式虽然可以达到获取第一个单词的目的，但是当字符串在获取下标值后进行了变动，原有的下标值去用在新字符串的时候就可能得到错误的结果，所以这时候就可以使用本节的解决方案：切片。

**字符串切片**

字符串切片是指向String对象中某个连续部分的引用，它的使用方式如下所示：

```rust
let s = String:from("hello world");
 
let hello = &s[0..5]; // 0..5意思是[0, 5)，左闭右开，取字符串s下标为0-4的字符串片段
let world = &s[6..11];
```

`s[start..end]`意思是创建一个String的切片引用，而不是对整个字符串本身的引用。

Rust的范围语法`..`是一个语法糖，当你希望范围从第一个元素（下标为0）开始时，可省略两点之前的数值，也就是说`[0..2]`等价于`[..2]`，同理如果想要从某个位置取到结尾`[3..len]`与`[3..]`等价。所以假设要创建整个字符串的所有字符的切片，可以用`[..]`或者`[0..len]`。前面的len都代表字符串的长度，即`s.len()`的值。

**注**：字符串切片的编辑必须位于有效的UTF-8字符边界内。尝试从一个多字节字符的中间位置创建字符串切片会导致运行的错误。在后面有专门讲解字符串的部分会详细说明UTF-8编码的文本的讨论内容。本节中用的是ASCII字符集，所以可以认为都是符合要求的。

前面提到了切片，这里就使用一下切片改写一下前面的函数，这里需要提一下，切片的类型写作`&str`：

```rust
fn first_word(s: &String) -> &str {  // 返回值类型改动
  let bytes = s.as_bytes();
  
  for (i, &item) in bytes.iter().enumerate() {
    if item == b' ' {
      return &s[0..i];  // 改动地方
    }
  } 
  &s[..] // 改动地方
}
```

因为传递过来的是s的引用，first_word函数创建了字符串s的切片引用，所以s只要是有效的，s的切片也是有效的。

**字符串字面量就是切片**

之前几篇文章中记录内容中，有类似`let s = "Hello world";`的定义，这里s其实就是`&str`类型，是一个不可变引用，它指向二进制程序特定位置的切片。

**将字符串切片作为参数**

既然可以分别创建字符串字面量和String的切片，那么就可以进一步优化first_word函数的接口，目前它的签名如下

```rust
fn first_word(s: &String) -> &str
```

比较有经验的Rust开发者会采用下面这种写法，这种改进后的签名使函数可以同时处理String和&str，这种做法可以使API更加通用，而且不会损失任何功能:

```rust
fn first_word(s: &str) -> &str
```

当参数是字符串切片的时候可以直接调用，如果是String类型的话，可以创建一个完整的String切片作为参数，可以尝试阅读下面的代码：

```rust
fn main() {
  let my_string = String::from("hello world");
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";
    let word = first_word(&my_string_literal[..]);

  	// 因为字符串字面量本身就是切片，所以下面这行也是成立的
    let word = first_word(my_string_literal);
}
```

除了前面提到的字符串切片外，还可以使用数组切片，例如：

```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3]; // 这里slice类型是&[i32]
```

**总结**

这一篇的切片以及之前的借用、所有权都是可以在编译时保证内存安全的关键。rust给予程序员完善的内存使用控制能力，除此之外，借助这些工具，rust还能自动清除那些所有者离开了作用域的数据，极大地减轻了使用者的负担，不需要专门编写销毁和测试代码。